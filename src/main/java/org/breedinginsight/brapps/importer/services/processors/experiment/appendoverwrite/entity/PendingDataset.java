package org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.entity;

import io.micronaut.context.annotation.Prototype;
import org.brapi.client.v2.model.exceptions.ApiException;
import org.brapi.v2.model.core.BrAPIListSummary;
import org.brapi.v2.model.core.request.BrAPIListNewRequest;
import org.brapi.v2.model.core.response.BrAPIListDetails;
import org.breedinginsight.brapi.v2.constants.BrAPIAdditionalInfoFields;
import org.breedinginsight.brapi.v2.dao.BrAPIListDAO;
import org.breedinginsight.brapps.importer.model.response.ImportObjectState;
import org.breedinginsight.brapps.importer.model.response.PendingImportObject;
import org.breedinginsight.brapps.importer.services.processors.experiment.ExperimentUtilities;
import org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.model.ExpUnitContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.model.ExpUnitMiddlewareContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.model.ImportContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.service.DatasetService;
import org.breedinginsight.services.exceptions.DoesNotExistException;
import org.breedinginsight.services.exceptions.MissingRequiredInfoException;
import org.breedinginsight.services.exceptions.UnprocessableEntityException;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Prototype
public class PendingDataset implements ExperimentImportEntity<BrAPIListDetails> {
    ExpUnitContext cache;
    ImportContext importContext;
    BrAPIListDAO brAPIListDAO;
    DatasetService datasetService;
    ExperimentUtilities experimentUtilities;

    public PendingDataset(ExpUnitMiddlewareContext context,
                          BrAPIListDAO brAPIListDAO,
                          DatasetService datasetService,
                          ExperimentUtilities experimentUtilities) {
        this.cache = context.getExpUnitContext();
        this.importContext = context.getImportContext();
        this.brAPIListDAO = brAPIListDAO;
        this.datasetService = datasetService;
        this.experimentUtilities = experimentUtilities;
    }
    /**
     * Create new objects generated by the workflow in the BrAPI service.
     *
     * @param members List of entities to be created
     * @return List of created entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<BrAPIListDetails> brapiPost(List<BrAPIListDetails> members) throws ApiException, MissingRequiredInfoException, UnprocessableEntityException, DoesNotExistException {
        // Construct BrAPI list requests
        List<BrAPIListNewRequest> requests = members.stream().map(details -> {
            BrAPIListNewRequest request = new BrAPIListNewRequest();
            request.setListName(details.getListName());
            request.setListType(details.getListType());
            request.setExternalReferences(details.getExternalReferences());
            request.setAdditionalInfo(details.getAdditionalInfo());
            request.data(details.getData());
            return request;
        }).collect(Collectors.toList());

        // The BrAPI service returns summaries with no data details but with system-generated dbIds
        List<BrAPIListSummary> summaries =  brAPIListDAO.createBrAPILists(requests, importContext.getProgram().getId(), importContext.getUpload());

        // Return the dataset data with system-generated dbId
        for (BrAPIListSummary summary : summaries) {
            for (BrAPIListDetails member : members) {
                if (member.getListName().equals(summary.getListName())) {
                    member.setListDbId(summary.getListDbId());
                }
            }
        }

        return members;
    }

    /**
     * Fetch objects required by the workflow from the BrAPI service.
     *
     * @return List of fetched entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<BrAPIListDetails> brapiRead() throws ApiException {
        // Get the id of the dataset belonging to the required exp units
        String datasetId = cache.getTrialByNameNoScope().values().iterator().next().getBrAPIObject()
                .getAdditionalInfo()
                .get(BrAPIAdditionalInfoFields.OBSERVATION_DATASET_ID)
                .getAsString();

        // Get the dataset belonging to required exp units
        return List.of(datasetService.fetchDatasetById(datasetId, importContext.getProgram()).orElseThrow(ApiException::new));
    }

    /**
     * Commit objects changed by the workflow to the BrAPI service.
     *
     * @param members List of entities to be updated
     * @return List of updated entities
     * @throws ApiException             if there is an issue with the API call
     * @throws IllegalArgumentException if method arguments are invalid
     */
    @Override
    public <U> List<U> brapiPut(List<U> members) throws ApiException, IllegalArgumentException {
        if (experimentUtilities.isInvalidMemberListForClass(members, BrAPIListDetails.class)) {
            return new ArrayList<U>();
        }

        List<U> updatedDatasets = new ArrayList<>();
        for (U member : members) {
            BrAPIListDetails obsVarList = (BrAPIListDetails) member;
            String obsVarListDbId = obsVarList.getListDbId();

            // Get the current observation variables for the dataset from the BrAPI service
            List<String> existingObsVarIds = brAPIListDAO.getListById(obsVarListDbId, importContext.getProgram().getId()).getResult().getData();

            // Find any observation variables that need to be added to the list in the BrAPI service
            List<String> newObsVarIds = obsVarList
                    .getData()
                    .stream()
                    .filter(obsVarId -> !existingObsVarIds.contains(obsVarId)).collect(Collectors.toList());

            // Save the additions to the list in the BrAPI service
            List<String> obsVarIds = new ArrayList<>(existingObsVarIds);
            obsVarIds.addAll(newObsVarIds);
            obsVarList.setData(obsVarIds);
            brAPIListDAO.updateBrAPIList(obsVarListDbId, obsVarList, importContext.getProgram().getId());
        }

        return updatedDatasets;
    }

    /**
     * Remove objects created by the workflow from the BrAPI service.
     *
     * @param members List of entities to be deleted
     * @return true if deletion is successful, false otherwise
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public <U> boolean brapiDelete(List<U> members) throws ApiException {
        // TODO: implement delete list for BrAPIJavaTestServer
        return false;
    }

    /**
     * For workflow pending import objects of a given state, fetch deep copies of the objects from the BrAPI service.
     *
     * @param status State of the objects
     * @return List of deep copies of entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<BrAPIListDetails> getBrAPIState(ImportObjectState status) throws ApiException {
        return new ArrayList<>();
    }

    /**
     * For workflow pending import objects of a given state, construct deep copies of the objects from the workflow context.
     *
     * @param status State of the objects
     * @return List of deep copies of entities from workflow context
     */
    @Override
    public List<BrAPIListDetails> copyWorkflowMembers(ImportObjectState status) {
        return experimentUtilities.copyWorkflowCachePendingBrAPIObjects(cache.getObsVarDatasetByName(), BrAPIListDetails.class, status);
    }

    /**
     * For objects in the workflow context, update any foreign-key fields with values generated by the BrAPI service.
     *
     * @param members List of entities to be updated
     */
    @Override
    public <U> void updateWorkflow(List<U> members) {
        // Check if the input list is of type List<BrAPIListDetails>
        if (experimentUtilities.isInvalidMemberListForClass(members, BrAPIListDetails.class)) {
            return;
        }

        for (U member : members) {
            BrAPIListDetails dataset = (BrAPIListDetails) member;

            // Update the dataset dbId
            cache.getObsVarDatasetByName().get(dataset.getListName()).getBrAPIObject().setListDbId(dataset.getListDbId());
        }

    }

    /**
     * Populate the workflow context with objects needed by the workflow.
     *
     * @param members List of entities to be initialized
     */
    @Override
    public <U> void initializeWorkflow(List<U> members) {
        // Check if the input list is of type List<BrAPIListDetails>
        if (experimentUtilities.isInvalidMemberListForClass(members, BrAPIListDetails.class)) {
            return;
        }

        // Construct the pending dataset from the BrAPI observation variable list
        List<PendingImportObject<BrAPIListDetails>> pendingDatasets = members.stream()
                .map(m -> (BrAPIListDetails) m)
                .map(dataset -> datasetService.constructPIOFromDataset(dataset, importContext.getProgram()))
                .collect(Collectors.toList());

        // Construct a hashmap to look up the pending dataset by dataset name
        Map<String, PendingImportObject<BrAPIListDetails>> pendingDatasetByName = pendingDatasets.stream()
                .collect(Collectors.toMap(pio -> pio.getBrAPIObject().getListName(),pio -> pio));

        // Construct a hashmap to look up the pending dataset by the observation unit ID of a unit stored in the BrAPI service
        Map<String, PendingImportObject<BrAPIListDetails>> pendingObsDatasetByOUId = cache.getPendingObsUnitByOUId().entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        e -> {
                            if (cache.getPendingTrialByOUId().isEmpty() ||
                                    pendingDatasetByName.isEmpty() ||
                                    !cache.getPendingTrialByOUId().values().iterator().next().getBrAPIObject().getAdditionalInfo().has(BrAPIAdditionalInfoFields.OBSERVATION_DATASET_ID)) {
                                throw new IllegalStateException("There is not an observation data set for this unit: " + e.getKey());
                            }
                            return pendingDatasetByName.values().iterator().next();
                        }
                ));

        // Add the maps to the context for use in processing import
        cache.setObsVarDatasetByName(pendingDatasetByName);
        cache.setPendingObsDatasetByOUId(pendingObsDatasetByOUId);
    }
}
