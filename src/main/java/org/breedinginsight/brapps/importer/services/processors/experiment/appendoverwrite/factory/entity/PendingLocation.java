/*
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.factory.entity;

import io.micronaut.context.annotation.Prototype;
import org.brapi.client.v2.model.exceptions.ApiException;
import org.brapi.v2.model.core.BrAPIStudy;
import org.breedinginsight.api.auth.AuthenticatedUser;
import org.breedinginsight.api.model.v1.request.ProgramLocationRequest;
import org.breedinginsight.brapps.importer.model.response.ImportObjectState;
import org.breedinginsight.brapps.importer.model.response.PendingImportObject;
import org.breedinginsight.brapps.importer.services.processors.experiment.ExperimentUtilities;
import org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.model.AppendOverwriteMiddlewareContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.model.AppendOverwriteWorkflowContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.model.ImportContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.service.LocationService;
import org.breedinginsight.model.ProgramLocation;
import org.breedinginsight.services.ProgramLocationService;
import org.breedinginsight.services.exceptions.DoesNotExistException;
import org.breedinginsight.services.exceptions.MissingRequiredInfoException;
import org.breedinginsight.services.exceptions.UnprocessableEntityException;

import java.util.*;
import java.util.stream.Collectors;

@Prototype
public class PendingLocation implements ExperimentImportEntity<ProgramLocation> {
    AppendOverwriteWorkflowContext cache;
    ImportContext importContext;
    ProgramLocationService programLocationService;
    LocationService locationService;
    ExperimentUtilities experimentUtilities;

    public PendingLocation(AppendOverwriteMiddlewareContext context,
                           ProgramLocationService programLocationService,
                           LocationService locationService,
                           ExperimentUtilities experimentUtilities) {
        this.cache = context.getAppendOverwriteWorkflowContext();
        this.importContext = context.getImportContext();
        this.programLocationService = programLocationService;
        this.locationService = locationService;
        this.experimentUtilities = experimentUtilities;
    }

    /**
     * Create new objects generated by the workflow in the BrAPI service.
     *
     * @param members List of entities to be created
     * @return List of created entities
     */
    @Override
    public List<ProgramLocation> brapiPost(List<ProgramLocation> members) throws MissingRequiredInfoException, UnprocessableEntityException, DoesNotExistException {
        // Construct requests
        List<ProgramLocationRequest> locationRequests = members.stream()
                .map(location -> ProgramLocationRequest.builder()
                        .name(location.getName())
                        .build())
                .collect(Collectors.toList());

        // Create acting user
        AuthenticatedUser actingUser = new AuthenticatedUser(importContext.getUpload().getUpdatedByUser().getName(), new ArrayList<>(), importContext.getUpload().getUpdatedByUser().getId(), new ArrayList<>());

        return programLocationService.create(actingUser, importContext.getProgram().getId(), locationRequests);
    }

    /**
     * Fetch objects required by the workflow from the BrAPI service.
     *
     * @return List of fetched entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<ProgramLocation> brapiRead() throws ApiException {
        // Get the dbIds of the studies belonging to the required exp units
        Set<String> locationDbIds = cache.getStudyByNameNoScope().values().stream().map(pio -> pio.getBrAPIObject().getLocationDbId()).collect(Collectors.toSet());

        // Get the locations belonging to required exp units
        return locationService.fetchLocationsByDbId(locationDbIds, importContext.getProgram());
    }

    /**
     * Commit objects changed by the workflow to the BrAPI service.
     *
     * @param members List of entities to be updated
     * @return List of updated entities
     * @throws IllegalArgumentException if method arguments are invalid
     */
    @Override
    public <U> List<U> brapiPut(List<U> members) throws IllegalArgumentException {
        return new ArrayList<>();
    }

    /**
     * Remove objects created by the workflow from the BrAPI service.
     *
     * @param members List of entities to be deleted
     * @return true if deletion is successful, false otherwise
     */
    @Override
    public <U> boolean brapiDelete(List<U> members) {
        // TODO: implement delete for program locations
        return false;
    }

    /**
     * For workflow pending import objects of a given state, fetch deep copies of the objects from the BrAPI service.
     *
     * @param status State of the objects
     * @return List of deep copies of entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<ProgramLocation> getBrAPIState(ImportObjectState status) throws ApiException {
        return new ArrayList<>();
    }

    /**
     * For workflow pending import objects of a given state, construct deep copies of the objects from the workflow context.
     *
     * @param status State of the objects
     * @return List of deep copies of entities from workflow context
     */
    @Override
    public List<ProgramLocation> copyWorkflowMembers(ImportObjectState status) {
        return experimentUtilities.copyWorkflowCachePendingBrAPIObjects(cache.getLocationByName(), ProgramLocation.class, status);
    }

    /**
     * For objects in the workflow context, update any foreign-key fields with values generated by the BrAPI service.
     *
     * @param members List of entities to be updated
     */
    @Override
    public <U> void updateWorkflow(List<U> members) {
        // Check if the input list is of type List<ProgramLocation>
        if (experimentUtilities.isInvalidMemberListForClass(members, ProgramLocation.class)) {
            return;
        }

        for (U member : members) {
            ProgramLocation location = (ProgramLocation) member;

            // Set the system-generated dbId for each newly created location
            cache.getLocationByName().get(location.getName()).getBrAPIObject().setLocationDbId(location.getLocationDbId());

            // Set the location dbid for cached studies
            cache.getStudyByNameNoScope().values().stream()
                    .filter(study -> location.getId().toString().equals(study.getBrAPIObject().getLocationDbId()))
                    .forEach(study -> study.getBrAPIObject().setLocationDbId(location.getLocationDbId()));
        }

    }

    /**
     * Populate the workflow context with objects needed by the workflow.
     *
     * @param members List of entities to be initialized
     */
    @Override
    public <U> void initializeWorkflow(List<U> members) {
        // Check if the input list is of type List<ProgramLocation>
        if (experimentUtilities.isInvalidMemberListForClass(members, ProgramLocation.class)) {
            return;
        }

        // Construct the pending locations from the BrAPI locations
        List<PendingImportObject<ProgramLocation>> pendingLocations = members.stream().map((U brapiLocation) -> locationService.constructPIOFromBrapiLocation((ProgramLocation) brapiLocation)).collect(Collectors.toList());

        // Construct a hashmap to look up the pending location by location name
        Map<String, PendingImportObject<ProgramLocation>> pendingLocationByName = pendingLocations.stream().collect(Collectors.toMap(pio -> pio.getBrAPIObject().getName(), pio -> pio));

        // Construct a hashmap to look up the pending location by the observation unit ID of a unit stored in the BrAPI service
        Map<String, PendingImportObject<ProgramLocation>> pendingLocationByOUId = cache.getPendingObsUnitByOUId().entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        e -> {
                            String name = Optional.ofNullable(e.getValue().getBrAPIObject().getLocationName())
                                    .orElseGet(() -> {
                                        PendingImportObject<BrAPIStudy> pendingStudy = cache.getPendingStudyByOUId().get(e.getKey());
                                        if (pendingStudy == null) {
                                            throw new IllegalStateException("Observation unit missing study: " + e.getKey());
                                        }
                                        return pendingStudy.getBrAPIObject().getLocationName();
                                    });
                            return Optional.ofNullable(pendingLocationByName.get(name))
                                    .orElseThrow(() -> new IllegalStateException("Observation unit missing location: " + e.getKey()));
                        }
                ));

        // Add the maps to the context for use in processing import
        cache.setLocationByName(pendingLocationByName);
        cache.setPendingLocationByOUId(pendingLocationByOUId);
    }
}
