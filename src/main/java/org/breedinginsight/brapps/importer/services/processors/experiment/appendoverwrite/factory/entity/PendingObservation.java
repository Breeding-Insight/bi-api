/*
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.factory.entity;

import io.micronaut.context.annotation.Prototype;
import org.apache.commons.collections4.map.CaseInsensitiveMap;
import org.brapi.client.v2.model.exceptions.ApiException;
import org.brapi.v2.model.pheno.BrAPIObservation;
import org.breedinginsight.brapi.v2.dao.BrAPIObservationDAO;
import org.breedinginsight.brapps.importer.model.response.ImportObjectState;
import org.breedinginsight.brapps.importer.services.processors.experiment.ExperimentUtilities;
import org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.model.AppendOverwriteMiddlewareContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.appendoverwrite.model.AppendOverwriteWorkflowContext;
import org.breedinginsight.brapps.importer.services.processors.experiment.model.ImportContext;
import org.breedinginsight.model.Trait;
import org.breedinginsight.services.OntologyService;
import org.breedinginsight.services.exceptions.DoesNotExistException;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Prototype
public class PendingObservation implements ExperimentImportEntity<BrAPIObservation> {
    AppendOverwriteWorkflowContext cache;
    ImportContext importContext;
    BrAPIObservationDAO brAPIObservationDAO;
    OntologyService ontologyService;
    ExperimentUtilities experimentUtilities;

    public PendingObservation(AppendOverwriteMiddlewareContext context,
                              BrAPIObservationDAO brAPIObservationDAO,
                              OntologyService ontologyService,
                              ExperimentUtilities experimentUtilities) {
        this.cache = context.getAppendOverwriteWorkflowContext();
        this.importContext = context.getImportContext();
        this.brAPIObservationDAO = brAPIObservationDAO;
        this.ontologyService = ontologyService;
        this.experimentUtilities = experimentUtilities;
    }


    /**
     * Create new objects generated by the workflow in the BrAPI service.
     *
     * @param members List of entities to be created
     * @return List of created entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<BrAPIObservation> brapiPost(List<BrAPIObservation> members) throws ApiException, DoesNotExistException {
        // TODO: move the trait setting out to a higher level
        // Fetch the program traits
        List<Trait> traits = ontologyService.getTraitsByProgramId(importContext.getProgram().getId(), true);
        CaseInsensitiveMap<String, Trait> traitMap = new CaseInsensitiveMap<>();
        for ( Trait trait: traits) {
            traitMap.put(trait.getObservationVariableName(),trait);
        }

        // Set the trait dbId on the observation requests
        for (BrAPIObservation observation : members) {
            String observationVariableName = observation.getObservationVariableName();
            if (observationVariableName != null && traitMap.containsKey(observationVariableName)) {
                String observationVariableDbId = traitMap.get(observationVariableName).getObservationVariableDbId();
                observation.setObservationVariableDbId(observationVariableDbId);
            }
        }

        // TODO: move this logic out to a higher level
        // Do not create observations in the BrAPI service if there is no value
        List<BrAPIObservation> nonBlankMembers = members.stream().filter(obs -> !obs.getValue().isBlank()).collect(Collectors.toList());

        // Create the observations
        return brAPIObservationDAO.createBrAPIObservations(nonBlankMembers, importContext.getProgram().getId(), importContext.getUpload());
    }

    /**
     * Fetch objects required by the workflow from the BrAPI service.
     *
     * @return List of fetched entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<BrAPIObservation> brapiRead() throws ApiException {
        return new ArrayList<>();
    }

    /**
     * Commit objects changed by the workflow to the BrAPI service.
     *
     * @param members List of entities to be updated
     * @return List of updated entities
     * @throws ApiException             if there is an issue with the API call
     * @throws IllegalArgumentException if method arguments are invalid
     */
    @Override
    public <U> List<U> brapiPut(List<U> members) throws ApiException, IllegalArgumentException {
        // Check if the input list is of type List<BrAPIObservation>
        if (experimentUtilities.isInvalidMemberListForClass(members, BrAPIObservation.class)) {
            return new ArrayList<U>();
        }

        List<BrAPIObservation> updatedObservations = new ArrayList<>();
        for (U member : members) {
            BrAPIObservation observation = (BrAPIObservation) member;
            Optional.ofNullable(brAPIObservationDAO.updateBrAPIObservation(observation.getObservationDbId(), observation, importContext.getProgram().getId())).ifPresent(updatedObservations::add);
        }

        return (List<U>) updatedObservations;
    }

    /**
     * Remove objects created by the workflow from the BrAPI service.
     *
     * @param members List of entities to be deleted
     * @return true if deletion is successful, false otherwise
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public <U> boolean brapiDelete(List<U> members) throws ApiException {
        // TODO: implement delete for observations on BrapiJavaTestServer
        return false;
    }

    /**
     * For workflow pending import objects of a given state, fetch deep copies of the objects from the BrAPI service.
     *
     * @param status State of the objects
     * @return List of deep copies of entities
     * @throws ApiException if there is an issue with the API call
     */
    @Override
    public List<BrAPIObservation> getBrAPIState(ImportObjectState status) throws ApiException {
        List<String> ids = copyWorkflowMembers(status).stream().map(BrAPIObservation::getObservationDbId).collect(Collectors.toList());
        return brAPIObservationDAO.getObservationsByDbIds(ids, importContext.getProgram());
    }

    /**
     * For workflow pending import objects of a given state, construct deep copies of the objects from the workflow context.
     *
     * @param status State of the objects
     * @return List of deep copies of entities from workflow context
     */
    @Override
    public List<BrAPIObservation> copyWorkflowMembers(ImportObjectState status) {
        return experimentUtilities.copyWorkflowCachePendingBrAPIObjects(cache.getPendingObservationByHash(), BrAPIObservation.class, status);
    }

    /**
     * For objects in the workflow context, update any foreign-key fields with values generated by the BrAPI service.
     *
     * @param members List of entities to be updated
     */
    @Override
    public <U> void updateWorkflow(List<U> members) {
        // Check if the input list is of type List<BrAPIObservation>
        if (experimentUtilities.isInvalidMemberListForClass(members, BrAPIObservation.class)) {
            return;
        }

        // Update the workflow ref by setting the system-generated dbId for each newly created trial
        for (U member : members) {
            BrAPIObservation observation = (BrAPIObservation) member;
            // TODO:set the observation dBId
        }
    }

    /**
     * Populate the workflow context with objects needed by the workflow.
     *
     * @param members List of entities to be initialized
     */
    @Override
    public <U> void initializeWorkflow(List<U> members) {
        // Check if the input list is of type List<BrAPIObservation>
        if (experimentUtilities.isInvalidMemberListForClass(members, BrAPIObservation.class)) {
            return;
        }

        // TODO:add previous observations
    }
}
